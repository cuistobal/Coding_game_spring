static void	generateCombinations(t_queue *queue, int *nums, int start, int *combination, int *originalIndexes, int combLen, int *queueIndex)
{
    int sum = 0;

    if (combLen > 1 && combLen <= DIRECTIONS)
    {
        for (int i = 0; i < combLen; i++)
            sum += combination[i];
        if (sum < MAX)
        {
            queue[*queueIndex].sum = sum;
            memcpy(queue[*queueIndex].indexes, originalIndexes, sizeof(int) * DIRECTIONS);
            (*queueIndex)++;
        }
    }

    for (int i = start; i < DIRECTIONS; i++)
    {
        combination[combLen] = nums[i];
        originalIndexes[i] = nums[i];
        generateCombinations(queue, nums, i + 1, combination, originalIndexes, combLen + 1, queueIndex);
        originalIndexes[i] = 0;
	}
}

//
static void	explore(t_queue *queue, int board[ROW_SIZE][COL_SIZE], int row, int col)
{
	int	new_row;
	int	new_col;
	int queueIndex = 0;
	int combinations[4];
	int nums[DIRECTIONS];
	int originalIndexes[DIRECTIONS] = {0};

	for (int  i = 0; i < DIRECTIONS; i++)
	{
        new_row = row + directions[i][IROW];
	    new_col = col + directions[i][ICOL];
   		if (check_position(board, new_row, new_col)) 
			nums[i] = board[new_row][new_col];
    }
	generateCombinations(queue, nums, 0, combinations, originalIndexes, 0, &queueIndex);
	for (int i = 0; i < 256; i++)
	{
		if (queue[i].sum != 0)
		{
			printf("%d ", queue[i].sum);
			for (int j = 0; j < 4; j++)
				printf(" %d", queue[i].indexes[j]);
			printf("\n");
		}
	}
}
